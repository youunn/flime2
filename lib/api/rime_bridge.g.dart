// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
import 'dart:ffi' as ffi;

/// Rime api
class RimeBridge {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  RimeBridge(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  RimeBridge.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  int init() {
    return _init();
  }

  late final _initPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('init');
  late final _init = _initPtr.asFunction<int Function()>();

  int start(
    ffi.Pointer<ffi.Char> dir,
  ) {
    return _start(
      dir,
    );
  }

  late final _startPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'start');
  late final _start =
      _startPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int process_key(
    int code,
    int mask,
  ) {
    return _process_key(
      code,
      mask,
    );
  }

  late final _process_keyPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'process_key');
  late final _process_key =
      _process_keyPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> get_commit() {
    return _get_commit();
  }

  late final _get_commitPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'get_commit');
  late final _get_commit =
      _get_commitPtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  int finalize() {
    return _finalize();
  }

  late final _finalizePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('finalize');
  late final _finalize = _finalizePtr.asFunction<int Function()>();

  void free_string(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _free_string(
      string,
    );
  }

  late final _free_stringPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'free_string');
  late final _free_string =
      _free_stringPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  void free_context(
    ffi.Pointer<SimpleContext> context,
  ) {
    return _free_context(
      context,
    );
  }

  late final _free_contextPtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<SimpleContext>)>>(
      'free_context');
  late final _free_context =
      _free_contextPtr.asFunction<void Function(ffi.Pointer<SimpleContext>)>();

  int is_composing() {
    return _is_composing();
  }

  late final _is_composingPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('is_composing');
  late final _is_composing = _is_composingPtr.asFunction<int Function()>();

  ffi.Pointer<SimpleContext> get_context() {
    return _get_context();
  }

  late final _get_contextPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<SimpleContext> Function()>>(
          'get_context');
  late final _get_context =
      _get_contextPtr.asFunction<ffi.Pointer<SimpleContext> Function()>();
}

class SimpleContext extends ffi.Struct {
  external ffi.Pointer<ffi.Char> preedit;

  external ffi.Pointer<ffi.Pointer<ffi.Char>> candidates;

  @ffi.Int()
  external int count;
}
